const fs = require("fs/promises");
const path = require("path");

const OUTPUT_DIR = "chapters";
const OUTPUT_FILE = "master.md";

const slugify = (str) =>
  str
    .toLowerCase()
    .replace(/[^\w\s-]/g, "")
    .replace(/\s+/g, "-");

const writeFile = async (dir, name, content) => {
  const filePath = path.join(dir, name);
  await fs.writeFile(filePath, content);
  console.log(`✅ Created: ${name}`);
};

const generateTOC = async (hierarchy, outputDir) => {
  const toc = Object.entries(hierarchy)
    .map(([parent, { children }]) => {
      const lines = [`- [${parent}](./000-${slugify(parent)}.md)`];
      lines.push(
        ...children.map(
          ({ title }) => `  - [${title}](./000-${slugify(title)}.md)`
        )
      );
      return lines.join("\n");
    })
    .join("\n");

  await writeFile(
    outputDir,
    "000-autogenerated-toc.md",
    `# Table of Contents\n\n${toc}`
  );
};

const parseHierarchy = (tocLines) => {
  const hierarchy = {};
  const parents = {};

  for (const line of tocLines) {
    const indent = line.match(/^\s*/)[0].length / 2;
    const [, title] = line.match(/\[(.+?)\]/);
    const [, anchor] = line.match(/\(#(.+?)\)/);

    if (indent === 0) {
      hierarchy[title] = { anchor, children: [] };
      parents[0] = { title, anchor };
    } else {
      const parent = parents[indent - 1];
      if (parent) {
        hierarchy[parent.title].children.push({ title, anchor });
      } else {
        hierarchy[title] = { anchor, children: [] };
      }
      parents[indent] = { title, anchor };
    }
  }

  return hierarchy;
};

const splitIndex = async () => {
  try {
    const content = await fs.readFile(OUTPUT_FILE, "utf-8");
    const sections = content.split("---\n\n").filter(Boolean);

    await fs.mkdir(OUTPUT_DIR).catch((err) => {
      if (err.code !== "EEXIST") throw err;
    });

    const tocSection = sections.find((s) => s.includes("## Table of contents"));
    const tocLines = tocSection
      .split("\n")
      .filter((line) => line.trim().startsWith("-"));

    const hierarchy = parseHierarchy(tocLines);
    await generateTOC(hierarchy, OUTPUT_DIR);

    const processed = new Set();
    let index = 0;

    const findSection = (title) =>
      sections.find((s) => s.match(/^#+\s+(.+)$/m)?.[1] === title);

    for (const [parent, { children }] of Object.entries(hierarchy)) {
      const parentSection = findSection(parent);
      if (!parentSection) continue;

      let content = parentSection.trim();

      for (const { title } of children) {
        const childSection = findSection(title);
        if (childSection) {
          const cleaned = childSection
            .split("\n")
            .filter((line) => !line.includes("*source:"))
            .join("\n")
            .trim();
          content += `\n\n---\n\n${cleaned}`;
          processed.add(title);
        }
      }

      const filename = `${String(index++).padStart(3, "0")}-${slugify(
        parent
      )}.md`;
      await writeFile(OUTPUT_DIR, filename, content);
      processed.add(parent);
    }

    for (const section of sections) {
      if (section.startsWith("# Master index")) continue;

      const match = section.match(/^#+\s+(.+)$/m);
      if (!match) continue;

      const title = match[1];

      const isChild = Object.values(hierarchy).some((p) =>
        p.children.some((c) => c.title === title)
      );

      if (!processed.has(title) && !isChild) {
        const filename = `${String(index++).padStart(3, "0")}-${slugify(
          title
        )}.md`;
        await writeFile(OUTPUT_DIR, filename, section.trim());
      }
    }

    console.log("✨ All files have been created successfully!");
  } catch (err) {
    console.error("❌ Error:", err);
    process.exit(1);
  }
};

splitIndex();
